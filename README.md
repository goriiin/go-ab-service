# Документация Go A/B Service

## 1. Архитектура и назначение сервисов

Система спроектирована для асинхронного, отказоустойчивого и масштабируемого управления A/B-тестами.

-   **`central-api`**
    -   **Назначение:** Ядро управления. Предоставляет REST API для CRUD-операций над экспериментами и синхронного получения решений. Является точкой входа для всех изменений конфигурации.
    -   **Влияние:** Прямо изменяет состояние в `postgres`. Единственный компонент, записывающий в базу данных экспериментов.

-   **`postgres`**
    -   **Назначение:** Источник истины (Source of Truth). Хранит полную и актуальную конфигурацию всех экспериментов.
    -   **Влияние:** Гарантирует персистентность данных. Все остальные компоненты системы в конечном итоге полагаются на данные из этой БД.

-   **`outbox-worker`**
    -   **Назначение:** Реализует паттерн Transactional Outbox. Гарантирует, что каждое изменение в `postgres` будет атомарно записано в виде события в таблицу `outbox` и затем надежно доставлено в `kafka`.
    -   **Влияние:** Обеспечивает надежность. Исключает потерю данных об изменениях при сбоях `central-api` или `kafka`.

-   **`kafka`**
    -   **Назначение:** Шина сообщений. Транспортирует события об изменениях (дельты) от `outbox-worker` к `client-sdk` и события о назначениях от `client-sdk` в систему аналитики.
    -   **Влияние:** Обеспечивает слабую связанность и асинхронность системы. Позволяет `client-sdk` обновляться в фоновом режиме без прямых запросов к `central-api`.

-   **`snapshot-generator`**
    -   **Назначение:** Периодически или по триггеру создает полные снимки (snapshots) всех активных экспериментов из `postgres`.
    -   **Влияние:** Оптимизирует холодный старт. Позволяет новым экземплярам `client-sdk` быстро загрузить актуальное состояние, не обрабатывая всю историю дельт.

-   **`minio`**
    -   **Назначение:** S3-совместимое хранилище. Хранит JSON-снэпшоты, созданные `snapshot-generator`.
    -   **Влияние:** Предоставляет `client-sdk` отказоустойчивую точку для загрузки полных конфигураций.

-   **`client-sdk` (в `example-sort-app`)**
    -   **Назначение:** Клиентская библиотека. Интегрируется в сервисы-потребители. Принимает решения о варианте для пользователя локально и сверхбыстро на основе закешированной в памяти конфигурации. В фоне слушает `kafka` для получения дельт и периодически сверяется с `minio` для самовосстановления.
    -   **Влияние:** Обеспечивает высокую производительность и отказоустойчивость на стороне клиента. Решения принимаются без сетевых задержек.

-   **`example-sort-app`**
    -   **Назначение:** Демонстрационный сервис. Показывает, как интегрировать и использовать `client-sdk` для реального A/B-теста.
    -   **Влияние:** Служит референсной реализацией и позволяет проводить сквозное тестирование системы.

## 2. Использование через `make`

-   **`make up`**
    -   **Действие:** Запускает все сервисы (`postgres`, `kafka`, `minio`, `central-api` и т.д.) в фоновом режиме. Использует `docker-compose.yml`.
    -   **Применение:** Для локальной разработки и ручного тестирования.

-   **`make down`**
    -   **Действие:** Останавливает все сервисы, запущенные через `make up`.
    -   **Применение:** Для остановки окружения.

-   **`make clean`**
    -   **Действие:** Останавливает все сервисы и **удаляет связанные с ними Docker-volumes** (`postgres_data`, `kafka_data`, `minio_data`).
    -   **Применение:** Для полной очистки состояния системы.

-   **`make test`**
    -   **Действие:** Запускает полное интеграционное тестирование. Поднимает отдельное, изолированное окружение с помощью `docker-compose.test.yml`, выполняет скрипт `test.sh` и затем уничтожает окружение вместе с volumes.
    -   **Применение:** Для автоматической проверки корректности работы всей системы.

-   **`make logs`**
    -   **Действие:** Выводит и отслеживает в реальном времени логи всех запущенных сервисов.
    -   **Применение:** Для отладки.

## 3. Ручное тестирование через cURL

Переменные для использования в запросах:
```bash
API_HOST="http://localhost:8080"
APP_HOST="http://localhost:8081"
EXPERIMENT_ID=""
```

### Шаг 1: Создание эксперимента (статус `DRAFT`)
Создается эксперимент с двумя вариантами, но он еще неактивен.
```bash
curl -s -X POST ${API_HOST}/experiments \
-H "Content-Type: application/json" \
-d '{
    "layer_id": "sorting_layer",
    "targeting_rules": [
        { "attribute": "use_sort_test", "operator": "EQUALS", "value": true }
    ],
    "variants": [
        { "name": "variant-a-asc", "bucket_range": [0, 499] },
        { "name": "variant-b-desc", "bucket_range": [500, 999] }
    ]
}' | jq
```
Из ответа извлечь `id` и присвоить переменной `EXPERIMENT_ID`:
```bash
EXPERIMENT_ID="<id_из_предыдущего_ответа>"
```

### Шаг 2: Активация эксперимента
Изменение статуса на `ACTIVE` и добавление списков принудительного включения.
```bash
curl -i -X PUT ${API_HOST}/experiments/${EXPERIMENT_ID} \
-H "Content-Type: application/json" \
-d '{
    "layer_id": "sorting_layer",
    "status": "ACTIVE",
    "targeting_rules": [
        { "attribute": "use_sort_test", "operator": "EQUALS", "value": true }
    ],
    "variants": [
        { "name": "variant-a-asc", "bucket_range": [0, 499] },
        { "name": "variant-b-desc", "bucket_range": [500, 999] }
    ],
    "override_lists": {
        "force_include": {
            "variant-a-asc": ["user-forced-asc"]
        }
    }
}'
```

### Шаг 3: Ожидание (критически важно)
Необходимо подождать 10-15 секунд, чтобы изменения через Kafka дошли до `client-sdk`.
```bash
sleep 15
```

### Шаг 4: Тестирование `central-api`
-   **Пользователь, попадающий под таргетинг (случайное распределение):**
    ```bash
    curl -s -X POST ${API_HOST}/decide \
    -H "Content-Type: application/json" \
    -d '{
        "user_id": "random-user-123",
        "attributes": { "use_sort_test": true }
    }' | jq
    # Ожидаемый ответ: {"<EXPERIMENT_ID>": "variant-a-asc"} или {"<EXPERIMENT_ID>": "variant-b-desc"}
    ```
-   **Пользователь, НЕ попадающий под таргетинг:**
    ```bash
    curl -s -X POST ${API_HOST}/decide \
    -H "Content-Type: application/json" \
    -d '{
        "user_id": "user-off-target",
        "attributes": { "use_sort_test": false }
    }' | jq
    # Ожидаемый ответ: {}
    ```

### Шаг 5: Тестирование `example-sort-app` (через `client-sdk`)
-   **Пользователь из `force_include` списка:**
    ```bash
    curl -s -X POST ${APP_HOST}/sort \
    -H "Content-Type: application/json" \
    -d '{"user_id": "user-forced-asc", "numbers": [5,1,4,2,3]}' | jq
    # Ожидаемый ответ: "variant_used": "variant-a-asc", "sorted_numbers": [1,2,3,4,5]
    ```
-   **Случайный пользователь, соответствующий таргетингу (ASC):**
    ```bash
    curl -s -X POST ${APP_HOST}/sort \
    -H "Content-Type: application/json" \
    -d '{"user_id": "user-asc", "numbers": [5,1,4,2,3]}' | jq
    # Ожидаемый ответ: "variant_used": "variant-a-asc", "sorted_numbers": [1,2,3,4,5]
    ```
-   **Случайный пользователь, соответствующий таргетингу (DESC):**
    ```bash
    curl -s -X POST ${APP_HOST}/sort \
    -H "Content-Type: application/json" \
    -d '{"user_id": "user-desc", "numbers": [5,1,4,2,3]}' | jq
    # Ожидаемый ответ: "variant_used": "variant-b-desc", "sorted_numbers": [5,4,3,2,1]
    ```

### Шаг 6: Получение конфигурации эксперимента
```bash
curl -s ${API_HOST}/experiments/${EXPERIMENT_ID} | jq
```

### Шаг 7: Удаление эксперимента
```bash
curl -i -X DELETE ${API_HOST}/experiments/${EXPERIMENT_ID}
# Ожидаемый ответ: HTTP/1.1 204 No Content
```

### Шаг 8: Проверка удаления
```bash
curl -i -X GET ${API_HOST}/experiments/${EXPERIMENT_ID}
# Ожидаемый ответ: HTTP/1.1 404 Not Found
```